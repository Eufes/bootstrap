
#Область Фабрика

//Функция создает фабрику XDTO из списка файлов XSD
//Параметры: Массив файлов - массив путей к файлам XSD
Функция СоздатьФабрикуXDTOИзМассиваФайлов(МассивФайлов) Экспорт
	
	НаборСхемXML = Новый НаборСхемXML;

	Для Каждого ФайлXSD из МассивФайлов цикл 
	
		ЧтениеXML = Новый ЧтениеXML;
		
		ЧтениеXML.ОткрытьФайл(ФайлXSD.ПолноеИмя);

		ПостроительDOM = Новый ПостроительDOM;
		
		ДокументDOM = ПостроительDOM.Прочитать(ЧтениеXML);
		
		ПостроительСхемыXML = Новый ПостроительСхемXML;
		
		СхемаXML = ПостроительСхемыXML.СоздатьСхемуXML(ДокументDOM);
		
		НаборСхемXML.Добавить(СхемаXML);
		
	КонецЦикла;
	
	НоваяФабрикаXDTO = Новый ФабрикаXDTO(НаборСхемXML);
	
	Возврат НоваяФабрикаXDTO;
	
КонецФункции

//Функция на основе текста запроса получает структуру таблиц и полей запроса
//
Функция ПолучитьСтруктуруПолейЗапроса(ТекстЗапроса) Экспорт
	
	СтруктураПолейЗапроса = Новый Структура;
	
	Если ТекстЗапроса = "" тогда
		Возврат СтруктураПолейЗапроса;
	КонецЕсли;
	
	СхемаЗапроса = Новый СхемаЗапроса;
	
	Попытка
		СхемаЗапроса.УстановитьТекстЗапроса(ТекстЗапроса);
	Исключение
		ТекстОшибки = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		QIWI_АдаптерШлюзБСПКлиентСервер.СообщитьПользователю(ТекстОшибки); 
		Возврат СтруктураПолейЗапроса;
	КонецПопытки;
	
	ПакетыСхемыЗапроса = СхемаЗапроса.ПакетЗапросов;
	
	ПерваяТаблица = Истина;
	
	НомерТаблиц = 1;
	
	Для каждого ПакетСхемыЗапроса из ПакетыСхемыЗапроса цикл
		
		Если ЗначениеЗаполнено(ПакетСхемыЗапроса.ТаблицаДляПомещения) тогда
			Продолжить;
		КонецЕсли;
		
		Если ПерваяТаблица тогда
			
			Для каждого Колонка из ПакетСхемыЗапроса.Колонки цикл
				СтруктураПолейЗапроса.Вставить(Колонка.Псевдоним);
			КонецЦикла;
			
			ПерваяТаблица = Ложь;
			
			Продолжить;
			
		КонецЕсли;
		
		СтруктураТЗ = Новый Структура;
		
		Для каждого Колонка из ПакетСхемыЗапроса.Колонки цикл
			СтруктураТЗ.Вставить(Колонка.Псевдоним);
		КонецЦикла;
		
		СтруктураПолейЗапроса.Вставить("ТаблицаЗначений" + Строка(НомерТаблиц), СтруктураТЗ);
		НомерТаблиц = НомерТаблиц + 1;
		
	КонецЦикла;
	
	Возврат СтруктураПолейЗапроса;
	
КонецФункции

//Функция получает структуру реквизитов и таблиц на основе типа объекта
//
//Параметры:
//	ТипОбъектаСистемы - СправочникСсылка.ИдентификаторыОбъектовМетаданных
//  ИсключитьСтандартныеРеквизиты - Булево 
//
Функция ПолучитьСтруктуруПолейОбъектаСистемыПоТипу(ТипОбъектаСистемы, ИсключитьСтандартныеРеквизиты = Ложь) Экспорт
	
	СтруктураПолейОбъекта = Новый Структура;
	
	Если НЕ ЗначениеЗаполнено(ТипОбъектаСистемы) ИЛИ ТипОбъектаСистемы.ЗначениеПустойСсылки = Неопределено тогда
		Возврат СтруктураПолейОбъекта;
	КонецЕсли;
	
	МетаданныеОбъекта = ТипОбъектаСистемы.ЗначениеПустойСсылки.Метаданные();
	
	Для Каждого Реквизит из МетаданныеОбъекта.Реквизиты цикл
		СтруктураПолейОбъекта.Вставить(Реквизит.Имя, Реквизит.Тип.Типы()[0]);   
	КонецЦикла;
	
	Если НЕ ИсключитьСтандартныеРеквизиты тогда
		Для Каждого Реквизит из МетаданныеОбъекта.СтандартныеРеквизиты цикл
			СтруктураПолейОбъекта.Вставить(Реквизит.Имя);
		КонецЦикла;
	КонецЕсли;
	
	Для Каждого ТабличнаяЧасть из МетаданныеОбъекта.ТабличныеЧасти цикл
		
		СтруктураТЗ = Новый Структура;
		
		Для Каждого Реквизит из ТабличнаяЧасть.Реквизиты цикл
			СтруктураТЗ.Вставить(Реквизит.Имя, Реквизит.Тип.Типы()[0]);
		КонецЦикла;
		
		СтруктураПолейОбъекта.Вставить(ТабличнаяЧасть.Имя, СтруктураТЗ);

	КонецЦикла;
	
	Возврат СтруктураПолейОбъекта;
	
КонецФункции

//Функция создает фабрику XDTO из списка файлов XSD
//Параметры: Массив файлов - массив путей к файлам XSD
Функция ПолучитьФабрикуXDTOИНаборСхемИзМассиваФайлов(МассивФайлов) Экспорт
	
	НаборСхемXML = Новый НаборСхемXML;

	Для Каждого ФайлXSD из МассивФайлов цикл 
	
		ЧтениеXML = Новый ЧтениеXML;
		
		ЧтениеXML.ОткрытьФайл(ФайлXSD.ПолноеИмя);

		ПостроительDOM = Новый ПостроительDOM;
		
		ДокументDOM = ПостроительDOM.Прочитать(ЧтениеXML);
		
		ПостроительСхемыXML = Новый ПостроительСхемXML;
		
		СхемаXML = ПостроительСхемыXML.СоздатьСхемуXML(ДокументDOM);
		
		НаборСхемXML.Добавить(СхемаXML);
		
	КонецЦикла;
	
	НоваяФабрикаXDTO = Новый ФабрикаXDTO(НаборСхемXML);
	
	СтруктураРезультат = Новый Структура("ФабрикаXDTO, НаборСхемXML", НоваяФабрикаXDTO, НаборСхемXML);
	
	Возврат СтруктураРезультат;
	
КонецФункции

#КонецОбласти // Фабрика

Функция ОсновнаяВерсияСхемИнтеграции() Экспорт
	
	//Возврат ПолучитьФункциональнуюОпцию("QIWI_АдаптерОсновнаяСхемаИнтеграции");
	
КонецФункции

Функция ПреобразоватьТекстАлгоритмаВТекстЗапроса(Текст) Экспорт
	
	Если СтрНачинаетсяС(Текст, "ВЫБРАТЬ") тогда
		Возврат Текст;
	КонецЕсли;
	
	НомерНачалаЗапроса = СтрНайти(Текст, """ВЫБРАТЬ");
	
	Если НомерНачалаЗапроса = 0 тогда
		Возврат "";
	КонецЕсли;
	
	НовыйТекстЗапроса = Сред(Текст, НомерНачалаЗапроса + 1); 
	
	НомерКонцаЗапроса = СтрНайти(НовыйТекстЗапроса, """;");
	
	НовыйТекстЗапроса = Лев(НовыйТекстЗапроса, НомерКонцаЗапроса - 1);
	
	НовыйТекстЗапроса = СтрЗаменить(НовыйТекстЗапроса, "|", "");
	НовыйТекстЗапроса = СтрЗаменить(НовыйТекстЗапроса, """""", """");
	
	Возврат НовыйТекстЗапроса;
	
КонецФункции

#Область Служебные //*************************************************

// Определяет принадлежность объекта метаданных к ссылочному типу.
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
// Возвращаемое значение:
//   Булево - Истина, если объект ссылочного типа.
//
Функция ЭтоОбъектСсылочногоТипа(ПроверяемыйОбъект) Экспорт
	
	Если ТипЗнч(ПроверяемыйОбъект) = Тип("ОбъектМетаданных") Тогда
		ИмяОбъектаМетаданных = ПроверяемыйОбъект.ПолноеИмя();
		Позиция = СтрНайти(ИмяОбъектаМетаданных, ".");
		Если Позиция > 0 Тогда 
			ИмяБазовогоТипа = Лев(ИмяОбъектаМетаданных, Позиция - 1);
			Возврат ИмяБазовогоТипа = "Справочник"
			Или ИмяБазовогоТипа = "Документ"
			Или ИмяБазовогоТипа = "БизнесПроцесс"
			Или ИмяБазовогоТипа = "Задача"
			Или ИмяБазовогоТипа = "ПланСчетов"
			Или ИмяБазовогоТипа = "ПланОбмена"
			Или ИмяБазовогоТипа = "ПланВидовХарактеристик"
			Или ИмяБазовогоТипа = "ПланВидовРасчета";
		Иначе
			Возврат Ложь;
		КонецЕсли;
		
	Иначе
		
	КонецЕсли;
	
КонецФункции

// Получить представление информационной базы для отображения пользователю.
//
// Возвращаемое значение:
//   Строка      - Представление информационной базы
//
// Пример возвращаемого результата:
// - для ИБ в файлом режиме: \\FileServer\1c_ib\
// - для ИБ в серверном режиме: ServerName:1111 / information_base_name
//
Функция ПолучитьПредставлениеИнформационнойБазы() Экспорт
	
	СтрокаСоединенияСБД = СтрокаСоединенияИнформационнойБазы();
	
	Если ИнформационнаяБазаФайловая(СтрокаСоединенияСБД) Тогда
		ПутьКБД = Сред(СтрокаСоединенияСБД, 6, СтрДлина(СтрокаСоединенияСБД) - 6);
	Иначе
		// надо к имени сервера прибавить имя пути информационной базы
		ПозицияПоиска = Найти(Врег(СтрокаСоединенияСБД), "SRVR=");
		
		Если ПозицияПоиска <> 1 Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		ПозицияТочкиСЗапятой = Найти(СтрокаСоединенияСБД, ";");
		НачальнаяПозицияКопирования = 6 + 1;
		КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
		
		ИмяСервера = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
		
		СтрокаСоединенияСБД = Сред(СтрокаСоединенияСБД, ПозицияТочкиСЗапятой + 1);
		
		// позиция имени сервера
		ПозицияПоиска = Найти(Врег(СтрокаСоединенияСБД), "REF=");
		
		Если ПозицияПоиска <> 1 Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		НачальнаяПозицияКопирования = 6;
		ПозицияТочкиСЗапятой = Найти(СтрокаСоединенияСБД, ";");
		КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
		
		ИмяИБНаСервере = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
		
		ПутьКБД = ИмяСервера + "/ " + ИмяИБНаСервере;
		
	КонецЕсли;
	
	Возврат ПутьКБД;
	
КонецФункции

// Функция ИнформационнаяБазаФайловая определяет режим эксплуатации
// информационной базы файловый (Истина) или Серверный (Ложь).
//  При проверке используется СтрокаСоединенияИнформационнойБазы, которую
// можно указать явно.
//
// Параметры:
//  СтрокаСоединенияИнформационнойБазы - Строка - параметр используется, если
//                 нужно проверить строку соединения не текущей информационной базы.
//
// Возвращаемое значение:
//  Булево.
//
Функция ИнформационнаяБазаФайловая(Знач СтрокаСоединенияИнформационнойБазы = "") Экспорт
			
	Если ПустаяСтрока(СтрокаСоединенияИнформационнойБазы) Тогда
		СтрокаСоединенияИнформационнойБазы =  СтрокаСоединенияИнформационнойБазы();
	КонецЕсли;
	Возврат Найти(Врег(СтрокаСоединенияИнформационнойБазы), "FILE=") = 1;
	
КонецФункции 

Функция ПриНачалеВыполненияРегламентногоЗадания(РеглЗадание, ИДРеглЗадания, ВнешняяСистема = Неопределено) Экспорт
	
	ИмяРеглЗадания = РеглЗадание.Имя;
		
	Если Не QIWI_АдаптерОбмен.РазрешитьРаботуАдаптера(ИДРеглЗадания, ИмяРеглЗадания) Тогда
		ТекстОшибки = "Работа адаптера не разблокирована. Для включения необходимо воспользовать командой "
						+ """Блокировка обмена (QIWI Адаптер)"" в общем интерфейсе или интерфейсе администратора";
		QIWI_АдаптерВызовСервера.ВыполнитьЛогирование("Операции адаптера заблокированы",
						УровеньЖурналаРегистрации.Информация, ТекстОшибки,
						ВнешняяСистема, Истина);
		Возврат Ложь;
	КонецЕсли;
	
	Если QIWI_АдаптерОбщегоНазначения.РегламентноеЗаданиеЗапущено(ИДРеглЗадания) Тогда
		ТекстОшибки = СтрШаблон("Регламентное задание %1 уже выполняется. 
								|Повторный запуск возможен после завершения текущего.", ИмяРеглЗадания);						
		QIWI_АдаптерВызовСервера.ВыполнитьЛогирование("Операции адаптера заблокированы",
						УровеньЖурналаРегистрации.Информация, ТекстОшибки,
						ВнешняяСистема, Истина);
		Возврат Ложь;  
	КонецЕсли; 	
	
	QIWI_АдаптерШлюзБСПСервер.ПриНачалеВыполненияРегламентногоЗадания(РеглЗадание);
	
	Возврат Истина;
	
КонецФункции	

// Определяет запущено ли регламентное задание
//
// Параметры:
//  КлючРеглЗадания	 - 	Строка - Имя объекта конфигурации
// 
// Возвращаемое значение:
//  Булево - Если рег. задание выполняется вернется истина, иначе ложь
//
Функция РегламентноеЗаданиеЗапущено(ИДРеглЗадания) Экспорт 
	
	РеглЗадание = РегламентныеЗадания.НайтиПоУникальномуИдентификатору(ИДРеглЗадания);
	 	
	Если РеглЗадание <> Неопределено Тогда
		Отбор = Новый Структура("РегламентноеЗадание, Состояние, КлючФоновогоЗадания");
		Отбор.РегламентноеЗадание = РеглЗадание;
		Отбор.Состояние = СостояниеФоновогоЗадания.Активно;		
		ИсполняющиеФоновыеЗадания = ФоновыеЗадания.ПолучитьФоновыеЗадания(Отбор);
		
		// Если есть активные фоновые задания - выходим 
		Возврат ИсполняющиеФоновыеЗадания.Количество() > 1;
	КонецЕсли;	
	
	Возврат Ложь;
	
КонецФункции

// Функция возвращает текст xml полученный из исходного текста xml из которого
// удалены недопустимые символы
//
Функция УдалитьНедопустимыеСимволыXML(ТекстXML) Экспорт

    Позиция = НайтиНедопустимыеСимволыXML(ТекстXML, , );

	Пока Позиция <> 0 Цикл
		ТекстXML = Лев(ТекстXML, Позиция - 1) + Сред(ТекстXML, Позиция + 1);
		Позиция = НайтиНедопустимыеСимволыXML(ТекстXML, , );
	КонецЦикла;

	ДлинаТекстаXML = СтрДлина(ТекстXML);
	МассивНекорректныхСимволов = Новый Массив;
	
	Для Сч = 1 По ДлинаТекстаXML Цикл 
		Символ = Сред(ТекстXML,Сч,1);
		КодСимвола = КодСимвола(Символ);
		Если (КодСимвола >= 32 И КодСимвола <= 126)         // Символы цифры и латиница  https://en.wikipedia.org/wiki/ISO/IEC_8859-5
			ИЛИ (КодСимвола >= 1025 И КодСимвола <= 1119) 	// Ёё Кирилица и другие
			ИЛИ КодСимвола = 9 		// табуляция
			ИЛИ КодСимвола = 10 	// Перенос строки
			ИЛИ КодСимвола = 8470 	// №
			ИЛИ КодСимвола = 167 	// §
			Тогда
			
			Продолжить;
		Иначе
			Если МассивНекорректныхСимволов.Найти(КодСимвола) = Неопределено Тогда
				МассивНекорректныхСимволов.Добавить(КодСимвола);
			КонецЕсли;
		КонецЕсли;		
	КонецЦикла;	
	
	Для Каждого НекорректныйКодСимвола Из МассивНекорректныхСимволов Цикл
		Если НекорректныйКодСимвола = 8211	//	дефис
			Тогда
			ТекстXML = СтрЗаменить(ТекстXML, Символ(НекорректныйКодСимвола), "-"); // производится замена символа дефис на -
		Иначе	
			ТекстXML = СтрЗаменить(ТекстXML, Символ(НекорректныйКодСимвола), " "); //заменяем на пробел
		КонецЕсли;	
	КонецЦикла;	
		
	ТекстXML = СтрЗаменить(ТекстXML, Символ(171), """"); // производится замена символа « на "
	ТекстXML = СтрЗаменить(ТекстXML, Символ(187), """"); // производится замена символа » на "
	ТекстXML = СтрЗаменить(ТекстXML, Символ(8222), """"); // производится замена символа „ на "
	ТекстXML = СтрЗаменить(ТекстXML, Символ(8220), """"); // производится замена символа “ на "
	                	 	
	Возврат ТекстXML;

КонецФункции //УдалитьНедопустимыеСимволыXML()

// Преобразовывает двоичные данные в формат base64
//
// Параметры:
//  ТекстовыеДанные  - Строка
//
// Возвращаемое значение:
//   вBase64 - строка двоичных данных в формате base64
//
Функция ДанныеВСтрокуBase64(ТекстовыеДанные, СжиматьВZip = Ложь, ТипДанных = "") Экспорт 
  
	Если Не ЗначениеЗаполнено(ТекстовыеДанные) Тогда 
		Возврат Неопределено;
	КонецЕсли; 	
		
	Если СжиматьВZip Тогда
		
		ИмяВременногоФайла  = ПолучитьИмяВременногоФайла();		
		ЗаписьТекста = Новый ЗаписьТекста(ИмяВременногоФайла);
		ЗаписьТекста.Записать(ТекстовыеДанные);
		ЗаписьТекста.Закрыть();
	
		НовыйАрхивИмя 	= ПолучитьИмяВременногоФайла();
		НовыйАрхив 		= Новый ЗаписьZIPФайла(НовыйАрхивИмя, , , МетодСжатияZIP.Сжатие);
		НовыйАрхив.Добавить(ИмяВременногоФайла, РежимСохраненияПутейZIP.НеСохранятьПути);
		ДанныеАрхива 	= Новый ДвоичныеДанные(НовыйАрхивИмя);
		вBase64 		= Base64Строка(ДанныеАрхива);
		
		УдалитьФайлы(НовыйАрхивИмя);
	Иначе
		Если ТипДанных = "Base64Значение" Тогда 		
			вBase64 = ТекстовыеДанные;
        Иначе
			ДвоичныеДанныеСтроки = ПолучитьДвоичныеДанныеИзСтроки(ТекстовыеДанные);
			вBase64 = Base64Строка(ДвоичныеДанныеСтроки);		
		КонецЕсли;	
	КонецЕсли;
	
	//Убираем пробелы и символы переноса строки;
	вBase64 = СтрЗаменить(СтрЗаменить(вBase64, Символ(10), ""), Символ(13), "");
		
	Возврат вBase64;
		
КонецФункции

#КонецОбласти // Служебные